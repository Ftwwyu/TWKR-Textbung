
;실제로 캐릭터를 이동시키는 함수 <-OLD
;@TB_캐릭이동(캐릭터,이동값,방향 = 0,Z기동력 = -1)
;#DIM DYNAMIC 캐릭터
;#DIM DYNAMIC 이동값
;#DIM DYNAMIC 방향
;#DIMS DYNAMIC TEMP_MOVE
;#DIM DYNAMIC 좌표변동방향,3
;#DIM DYNAMIC Z기동력
;IF !방향
;    T_위치:캐릭터:0 += 이동값
;    IF T_위치:캐릭터:0 >= TB_위치값한계
;        이동값 -= T_위치:캐릭터:0 - TB_위치값한계
;        T_위치:캐릭터:0 = TB_위치값한계
;    ELSEIF T_위치:캐릭터:0 <= 0
;        이동값 += 0 - T_위치:캐릭터:0
;        T_위치:캐릭터:0 = 0
;    ENDIF
;ELSE
;    VARSET LOCAL
;    DEBUGPRINTFORML %CALLNAME:캐릭터%: 각도 {방향}도, 거리{이동값}
;    IF 방향 / 1000
;        SIF Z기동력 == -1
;            Z기동력 = TB_MAX_VALUE(캐릭터,TCV_비행)
;        IF !Z기동력 ;Z기동 불가시엔 Z각도를 제거
;            방향 = 방향 % 10000
;        ENDIF
;    ENDIF
;    WHILE 이동값 >= 1 && LOCAL < 100
;        LOCAL++
;        CALL T_ANGLE_TAN_TO_WAY(방향,이동값)
;        이동값 = RESULT:3
;        DEBUGPRINTFORML XYZ이동값{이동값}, XYZ{RESULT},{RESULT:1},{RESULT:2}
;        T_위치:캐릭터:0 = LIMIT(T_위치:캐릭터:0 + RESULT,0,TB_위치값한계)
;        T_위치:캐릭터:1 = LIMIT(T_위치:캐릭터:1 + RESULT:1,0,TB_위치값한계)
;        T_위치:캐릭터:2 = LIMIT(T_위치:캐릭터:2 + RESULT:2,0,TB_위치값한계)
;    WEND
;ENDIF
;RETURN 이동값

;실제로 캐릭터를 이동시키는 함수 <- NEW
@TB_CHARAMOVE(캐릭터,이동값,방향,Z기동력 = -1,XY기동력 = 500)
#DIM DYNAMIC 캐릭터
#DIM DYNAMIC 이동값
#DIM REF 방향,0
#DIMS DYNAMIC TEMP_MOVE
#DIM DYNAMIC 좌표변동방향,3
#DIM DYNAMIC Z기동력
#DIM DYNAMIC XY기동력

VARSET LOCAL
IF 방향:0 > 1000 ;ANGLE이 아닌 INT식으로 입력함
    DEBUGPRINTFORML CHARAMOVE: 방향이 INT 형식으로 입력됨 -> {방향}
    방향:1 = 방향:0 / 10000
    IF 방향:1 / 1000 == 1
        방향:1 = -1 * (방향:1 % 1000)
    ENDIF
    방향:0 = 방향:0 % 10000
    IF 방향:0 / 1000 == 1
        방향:0 = -1 * (방향:0 % 1000)
    ENDIF
ENDIF
DEBUGPRINTFORML %CALLNAME:캐릭터%: 각도 {방향}도, 거리{이동값}
SIF Z기동력 == -1
    Z기동력 = TB_MAX_VALUE(캐릭터,TCV_비행)
IF !Z기동력 ;Z기동 불가시엔 Z각도를 제거
    방향:1 = 0
ENDIF
WHILE 이동값 >= 1 && LOCAL < 100
    LOCAL++
    CALL T_ANGLE_TAN_TO_WAY(방향:0,이동값,방향:1,Z기동력)
    이동값 = RESULT:3
    DEBUGPRINTFORML XY이동값{이동값}, XYZ{RESULT},{RESULT:1}
    T_위치:캐릭터:0 = LIMIT(T_위치:캐릭터:0 + RESULT,0,TB_위치값한계)
    T_위치:캐릭터:1 = LIMIT(T_위치:캐릭터:1 + RESULT:1,0,TB_위치값한계)
    T_위치:캐릭터:2 = LIMIT(T_위치:캐릭터:2 + RESULT:2,0,TB_위치값한계)
WEND
RETURN 이동값

;몇 턴마다 갱신되는지
@이동갱신주기(ARG)
#FUNCTION
IF ARG < 10
    RETURNF 10 / ARG
ENDIF
RETURNF 1

;주기마다 몇M 이동하는지
@이동갱신거리(ARG)
#FUNCTION
IF ARG < 10
    RETURNF 1
ENDIF
RETURNF ARG

;특정 좌표로 순간 이동 시킴
@TB_순간이동(캐릭터,좌표)
#DIM DYNAMIC 캐릭터
#DIM DYNAMIC 좌표
CALL TB_INTTOMAP(좌표)
T_위치:캐릭터:0 = RESULT:2
T_위치:캐릭터:1 = RESULT:1
T_위치:캐릭터:2 = RESULT:0
RETURN 좌표

;대상간의 거리, 혹은 대상과 지점간의 거리를 측정
;은신과는 영향이 없음, 절대거리만을 측정
@TB_거리(대상 = 0,좌표 = 0)
#FUNCTION
#DIM DYNAMIC 대상
#DIM DYNAMIC 좌표
LOCAL = 99
IF 좌표
    RETURNF T_INTTORANGE((T_INTLOCATE(대상)),좌표)
ELSE
    RETURNF T_INTTORANGE((T_INTLOCATE(대상)),(T_INTLOCATE(사용자반대(대상))))
ENDIF

;은신 등에 의해 왜곡되는 거리, 무조건 대상 번호를 전달해야함
@TB_거리_은신(대상,좌표 = 0)
#FUNCTION
#DIM DYNAMIC 대상
#DIM DYNAMIC 좌표
IF 좌표
    LOCAL = TB_MAX_VALUE(사용자반대(대상),TCV_은신간파)
    RETURNF T_INTTORANGE((T_INTLOCATE(대상,LOCAL)),좌표)
ELSE
    LOCAL = TB_MAX_VALUE(사용자반대(대상),TCV_은신간파)
    RETURNF T_INTTORANGE((T_INTLOCATE(대상,LOCAL)),(T_INTLOCATE(사용자반대(대상),LOCAL)))
ENDIF


;이동력을 바탕으로 이동거리를 계산해서 이동함
@TB_MOVE(캐릭터,좌표,제한 = 0)
#DIM DYNAMIC 캐릭터
#DIM REF 좌표,0
#DIM DYNAMIC 방향,2
#DIM DYNAMIC 거리
#DIM DYNAMIC 제한
CALL 행동기회소모(캐릭터,T_이동행동)
거리 = T_INTTORANGE(TB_MAPTOINT(T_위치:캐릭터:0,T_위치:캐릭터:1,T_위치:캐릭터:2),TB_LOCATETOINT(좌표))
IF 제한 == 1
    거리 = 거리 / 2
ENDIF
IF 좌표:2 == -1 ; 좌표가 아닌 방향을 받음
    방향 = 좌표:0
    DEBUGPRINTFORML %CALLNAME:캐릭터%의 이동처리 개시:{TB_MAPTOINT(T_위치:캐릭터:0,T_위치:캐릭터:1,T_위치:캐릭터:2)}(거리:{ARG능력치(캐릭터,"이동력")/(1 + 제한)})(방향:%T_ANGLETOSTR(방향)%)
    CALL TB_CHARAMOVE(캐릭터,ARG능력치(캐릭터,"이동력")/(1 + 제한), 방향)
ELSEIF 거리 > ARG능력치(캐릭터,"이동력")
    ;1턴에 갈 수 있는 거리가 아냐
    CALL T_INTTOANGLE(TB_MAPTOINT(T_위치:캐릭터:0,T_위치:캐릭터:1,T_위치:캐릭터:2),TB_LOCATETOINT(좌표),방향)
    ;방향 = RESULT:0
    DEBUGPRINTFORML %CALLNAME:캐릭터%의 이동처리 개시:{TB_MAPTOINT(T_위치:캐릭터:0,T_위치:캐릭터:1,T_위치:캐릭터:2)} -> {좌표}(거리:{거리})(방향:%T_ANGLETOSTR(방향)%)
    CALL TB_CHARAMOVE(캐릭터,ARG능력치(캐릭터,"이동력"), 방향)
ELSE
    ;1턴 안에 갈 수 있으면 순간이동
    DEBUGPRINTFORML %CALLNAME:캐릭터%의 이동처리 개시:{TB_MAPTOINT(T_위치:캐릭터:0,T_위치:캐릭터:1,T_위치:캐릭터:2)} -> {좌표}(거리:{거리})(근접순간이동)
    CALL TB_순간이동(캐릭터,좌표)
ENDIF

;혹여 이상하게 건드렸다가 값 꼬이지 않게 + 코드가 단정해짐
;@TB_위치(ARG,디코이무시 = -1)
;#FUNCTION
;#DIM DYNAMIC 디코이무시
;IF 디코이무시 == -1 || ARG == T_시전자
;    디코이무시 = 99
;ENDIF
;IF 디코이무시 >= TB_MAX_VALUE(ARG,TCV_은신) || 0 >= TB_MAX_VALUE(ARG,TCV_은신)
;    LOCAL = T_위치:ARG:0
;ELSE
;    LOCAL:1 = RAND:TB_MAX_VALUE(ARG,TCV_은신)
;    IF GROUPMATCH(T_위치:ARG:0,TB_위치값한계,0)
;        IF T_위치:ARG:0 == 0
;            ;무조건 양수로만
;            LOCAL:1 *= 1
;        ELSE
;            ;무조건 음수로만
;            LOCAL:1 *= -1
;        ENDIF
;    ELSE
;        IF RAND:2 == 0
;            ;50% 확률로 방향 역전
;            LOCAL:1 *= -1
;        ENDIF
;    ENDIF
;    LOCAL = LIMIT(T_위치:ARG:0 + LOCAL:1,0,TB_위치값한계)
;ENDIF
;RETURNF LOCAL

;ARG의 입장에서 ARG:1의 방향
@TB_방향(ARG,ARG:1)
#FUNCTION
IF ARG == 0 && ARG:1 == 0
    ARG = T_위치:T_시전자:0
    ARG:1 = T_위치:T_시전자반대:0
ENDIF
IF ARG < ARG:1
    RETURNF 1
ELSEIF ARG == ARG:1
    RETURNF 1
ELSEIF ARG > ARG:1
    RETURNF -1
ENDIF


@TB_돌진(시전자,대상자,이격,최대거리,Z기동력 = -1)
#DIM DYNAMIC 시전자
#DIM DYNAMIC 대상자
#DIM DYNAMIC 이격
#DIM DYNAMIC 최대거리
#DIM DYNAMIC 거리
#DIM DYNAMIC 최종거리
#DIM DYNAMIC 좌표1,3
#DIM DYNAMIC 좌표2,3
#DIM DYNAMIC 방향,3
#DIM DYNAMIC Z기동력

CALL T_LOCATE(시전자,좌표1)
CALL T_LOCATE(대상자,좌표2)
CALL T_ANGLE(좌표1,좌표2,방향) ;이격 효과를 주기 위해
거리 = T_RANGE(좌표1,좌표2)

최종거리 = ABS(거리 + 이격) ;혹시나 음수가 되면 곤란하다
IF 최종거리 > 최대거리
    최종거리 = 최대거리
ENDIF

CALL TB_CHARAMOVE(시전자,최종거리,방향,Z기동력)


@T_MOVEABLE(시전자)
#FUNCTION
#DIM DYNAMIC 시전자
IF TB_SUM_REMAIN(시전자,TCV_속박)
    RETURNF 0
ENDIF
RETURNF 1


@T_TPABLE(시전자)
#FUNCTION
#DIM DYNAMIC 시전자
IF TB_SUM_REMAIN(시전자,TCV_봉쇄)
    RETURNF 0
ENDIF
RETURNF 1


@T_LOCATE(ARG,배열,디코이무시 = -1)
#DIM REF 배열,0
#DIM DYNAMIC 디코이무시
VARSET LOCAL
IF 디코이무시 == -1 || 디코이무시 >= TB_MAX_VALUE(ARG,TCV_은신) || 0 >= TB_MAX_VALUE(ARG,TCV_은신)
ELSE
    LOCAL:0 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1) ;0 > 0 > -1 / 1 > 2 > 1
    LOCAL:1 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1)
    LOCAL:2 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1)
ENDIF
배열:0 = LIMIT(T_위치:ARG:0 + LOCAL:0,0,TB_위치값한계)
배열:1 = LIMIT(T_위치:ARG:1 + LOCAL:1,0,TB_위치값한계)
배열:2 = LIMIT(T_위치:ARG:2 + LOCAL:2,0,TB_위치값한계)
RETURN T_위치:ARG:0

@T_INTLOCATE(ARG,디코이무시 = -1)
#FUNCTION
#DIM DYNAMIC 디코이무시
VARSET LOCAL
IF 디코이무시 == -1 || 디코이무시 >= TB_MAX_VALUE(ARG,TCV_은신) || 0 >= TB_MAX_VALUE(ARG,TCV_은신)
ELSE
    LOCAL:0 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1) ;0 > 0 > -1 / 1 > 2 > 1
    LOCAL:1 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1)
    LOCAL:2 = RAND:TB_MAX_VALUE(ARG,TCV_은신) * (RAND:2 * 2 - 1)
ENDIF
LOCAL:0 = LIMIT(T_위치:ARG:0 + LOCAL:0,0,TB_위치값한계)
LOCAL:1 = LIMIT(T_위치:ARG:1 + LOCAL:1,0,TB_위치값한계)
LOCAL:2 = LIMIT(T_위치:ARG:2 + LOCAL:2,0,TB_위치값한계)
RESULT = 1000000 + LOCAL:0 * 1000000 + LOCAL:1 * 1000 + LOCAL:2
RETURNF RESULT

@T_RANGE(좌표1,좌표2)
#DIM REF 좌표1,0
#DIM REF 좌표2,0
#FUNCTION
    RETURNF SQRT(POWER(좌표2:0-좌표1:0,2)+POWER(좌표2:1-좌표1:1,2)+POWER(좌표2:2-좌표1:2,2))

@T_INTTORANGE(ARG,ARG:1)
#FUNCTION
#DIM DYNAMIC 좌표1,3
#DIM DYNAMIC 좌표2,3
;INTTOMAP을 쓰고싶지만 FUNCTION 안에서 일반함수를 호출할 수 없으니...
ARG -= 1000000
좌표1:0 = ARG / 1000000
좌표1:1 = (ARG % 100000) / 1000
좌표1:2 = ARG % 1000

ARG:1 -= 1000000
좌표2:0 = ARG:1 / 1000000
좌표2:1 = (ARG:1 % 100000) / 1000
좌표2:2 = ARG:1 % 1000

RETURNF T_RANGE(좌표1,좌표2)

;좌표를 각도로
@T_ANGLE(좌표1,좌표2,각도)
#DIM REF 좌표1,0
#DIM REF 좌표2,0
#DIM REF 각도,0
각도:1 = T_ANGLE_TAN(좌표2:0 - 좌표2:0, 좌표2:2 - 좌표1:2)
IF 각도:1 == 180 || 각도:1 == 0
    각도:1 = 0
ENDIF
각도:0 = T_ANGLE_TAN(좌표2:0 - 좌표1:0, 좌표2:1 - 좌표1:1)
RESULT += LOCAL
;RESULT / 10000 -> Z 각도, RESULT % 10000 -> X와 Y로 각도
;1000의 자리가 1일때는 음수라는 뜻
RETURN RESULT

;INT 좌표를 받아 해당하는 각도를 INT형식으로 반환
@T_I_ANGLE_F(원좌표1,원좌표2)
#FUNCTION
#DIM DYNAMIC 원좌표1
#DIM DYNAMIC 원좌표2
#DIM DYNAMIC 좌표1,3
#DIM DYNAMIC 좌표2,3
#DIM DYNAMIC 각도,2
좌표1:0 = TB_RETURN_X(원좌표1)
좌표1:1 = TB_RETURN_Y(원좌표1)
좌표1:2 = TB_RETURN_Z(원좌표1)
좌표2:0 = TB_RETURN_X(원좌표2)
좌표2:1 = TB_RETURN_Y(원좌표2)
좌표2:2 = TB_RETURN_Z(원좌표2)

각도:1 = T_ANGLE_TAN(좌표2:0 - 좌표2:0, 좌표2:2 - 좌표1:2)
IF 각도:1 == 180 || 각도:1 == 0
    각도:1 = 0
ENDIF
각도:0 = T_ANGLE_TAN(좌표2:0 - 좌표1:0, 좌표2:1 - 좌표1:1)
RETURNF T_ANGLETOINT(각도:0,각도:1)

@T_ANGLETOINT(각도1,각도2)
#FUNCTION
#DIM DYNAMIC 각도1 ;XY
#DIM DYNAMIC 각도2 ;Z
IF SIGN(각도2) == -1
    각도2 = ABS(각도2) + 1000
ENDIF
IF SIGN(각도1) == -1
    각도1 = ABS(각도1) + 1000
ENDIF
RETURNF 각도2 * 10000 + 각도1

;버튼으로 된 좌표를 각도로
@T_INTTOANGLE(ARG,ARG:1,각도)
#DIM DYNAMIC 좌표1,3
#DIM DYNAMIC 좌표2,3
#DIM REF 각도,0
;INTTOMAP을 쓰고싶지만 FUNCTION 안에서 일반함수를 호출할 수 없으니...
ARG -= 1000000
좌표1:0 = ARG / 1000000
좌표1:1 = (ARG % 1000000) / 1000
좌표1:2 = ARG % 1000

ARG:1 -= 1000000
좌표2:0 = ARG:1 / 1000000
좌표2:1 = (ARG:1 % 1000000) / 1000
좌표2:2 = ARG:1 % 1000
CALL T_ANGLE(좌표1,좌표2,각도)
RETURN 각도

@T_ANGLETOSTR(ARG)
#FUNCTIONS
#DIM DYNAMIC 증감치,3
VARSET RESULTS
LOCAL = ARG / 10000
SIF LOCAL / 1000 == 1
    LOCAL = -1 * (LOCAL % 1000)
LOCAL:1 = ARG % 10000
SIF LOCAL:1 / 1000 == 1
    LOCAL:1 = -1 * (LOCAL:1 % 1000)
;전장은 2사분면이므로 조금 변환이 필요
IF LOCAL:1 == 360
    SELECTCASE LOCAL
        CASE 0
            ;가만히
        CASE IS <= -1
            RESULTS += "아래쪽"
        CASE IS >= 1
            RESULTS += "위쪽"
    ENDSELECT
ELSE
    SELECTCASE LOCAL:1
        CASE 0
            ;동
            RESULTS '= "동"
        CASE 1 TO 89
            ;북동
            RESULTS '= "남동"
        CASE 90
            ;북
            RESULTS '= "남"
        CASE 91 TO 179
            ;북서
            RESULTS '= "남서"
        CASE 180
            ;서
            RESULTS '= "서"
        CASE -180 TO -91
            ;남서
            RESULTS '= "북서"
        CASE -90
            ;남
            RESULTS '= "북"
        CASE -79 TO -1
            ;남동
            RESULTS '= "북동"
    ENDSELECT
    SELECTCASE LOCAL
        CASE 0
            RESULTS += "쪽"
        CASE IS <= -1
            RESULTS += "쪽 아랫 방향"
        CASE IS >= 1
            RESULTS += "쪽 윗 방향"
    ENDSELECT
ENDIF
RETURNF RESULTS

;각도를 바탕으로 이동 목적지를 도출해냄
@T_ANGLE_TAN_TO_WAY(각도,이동력,Z각도 = 0,Z한계 = 0,XY한계 = 500)
#DIM DYNAMIC 각도
#DIM DYNAMIC 이동력
#DIM DYNAMIC Z각도
#DIM DYNAMIC Z한계
#DIM DYNAMIC XY한계
#DIM DYNAMIC XX ;DX
#DIM DYNAMIC YY ;DY
#DIM DYNAMIC ZZ ;DZ
LOCAL = T_ANGLE_TAN_TO_WAY_F(각도,이동력,Z각도,Z한계,XY한계)

XX = (LOCAL % 100000000) / 1000000
YY = (LOCAL % 1000000) / 10000
ZZ = (LOCAL % 10000) / 100

SELECTCASE LOCAL / 100000000
    CASE 1
        XX *= -1
    CASE 2
        YY *= -1
    CASE 3
        XX *= -1
        YY *= -1
    CASE 4
        ZZ *= -1
    CASE 5
        XX *= -1
        ZZ *= -1
    CASE 6
        YY *= -1
        ZZ *= -1
    CASE 7
        XX *= -1
        YY *= -1
        ZZ *= -1
ENDSELECT
이동력 = LOCAL % 100

RESULT:0 = XX
RESULT:1 = YY
RESULT:2 = ZZ
RESULT:3 = 이동력
RETURN RESULT:0

@T_ANGLE_TAN_TO_WAY_F(각도,이동력,Z각도 = 0,Z한계 = 0,XY한계 = 500)
#FUNCTION
#DIM DYNAMIC XX ;DX
#DIM DYNAMIC YY ;DY
#DIM DYNAMIC ZZ ;DZ
#DIM DYNAMIC X목표
#DIM DYNAMIC Y목표
#DIM DYNAMIC Z목표
#DIM DYNAMIC 각도
#DIM DYNAMIC XY각도
#DIM DYNAMIC Z각도
#DIM DYNAMIC Z한계
#DIM DYNAMIC XY한계
#DIM DYNAMIC 이동력
#DIM DYNAMIC DONE,2
IF Z각도 == 180 || Z각도 == 0
    Z각도 = 0
    Z목표 = 0
    DONE:0 = 3
ENDIF
XY각도 = 각도
SELECTCASE XY각도
    CASE 90
        YY += 이동력
        이동력 = 0
        GOTO END
    CASE 45
        YY += 이동력
        XX += 이동력 
        이동력 = 0
        GOTO END
    CASE 0
        XX += 이동력 
        이동력 = 0
        GOTO END
    CASE -45
        YY -= 이동력
        XX += 이동력 
        이동력 = 0
        GOTO END
    CASE -90
        YY -= 이동력 
        이동력 = 0
        GOTO END
    CASE -135
        YY -= 이동력
        XX -= 이동력 
        이동력 = 0
        GOTO END
    CASE 135
        YY += 이동력
        XX -= 이동력 
        이동력 = 0
        GOTO END
    CASE 180
        XX -= 이동력
        이동력 = 0
        GOTO END
    CASE 360
        SELECTCASE Z각도
            CASE 90
                ZZ += 이동력
                이동력 = 0
                GOTO END
            CASE -90
                ZZ -= 이동력
                이동력 = 0
                GOTO END
        ENDSELECT
    CASEELSE
ENDSELECT
FOR LOCAL,0,TB_ANGLE_범위 * 2
    FOR LOCAL:1,0,TB_ANGLE_범위 * 2
        IF TB_ANGLE_차트:(LOCAL):(LOCAL:1) == Z각도 && !DONE:0
            LOCAL:2 = ABS(LOCAL:0) ;수직 이동만 따지므로 그냥 DY만 넣어도 충분
            IF LOCAL:2 > 이동력
                ;갈 수 있는 거리보다 멀다
                ;일단 임시 저장만
                Z목표 = LOCAL:0
                IF LOCAL > TB_ANGLE_범위
                    ;중간값을 넘기면 Y가 커질수록 거리가 더 벌어지게 되니까 그만두어야함
                    DONE:0 = 1
                ENDIF
            ELSEIF LOCAL:2 <= 이동력
                ZZ = LOCAL:1 - TB_ANGLE_범위
                DONE:0 = 2
            ENDIF
        ENDIF

        IF TB_ANGLE_차트:(LOCAL):(LOCAL:1) == XY각도 && !DONE:1
            LOCAL:2 = SQRT(POWER(LOCAL - TB_ANGLE_범위,2) + POWER(LOCAL:1 - TB_ANGLE_범위,2))
            IF LOCAL:2 > 이동력
                ;갈 수 있는 거리보다 멀다
                ;일단 임시 저장만
                X목표 = LOCAL:1
                Y목표 = LOCAL:0
                IF LOCAL > TB_ANGLE_범위
                    ;중간값을 넘기면 Y가 커질수록 거리가 더 벌어지게 되니까 그만두어야함
                    DONE:1 = 1
                ENDIF
            ELSEIF LOCAL:2 <= 이동력
                YY = LOCAL - TB_ANGLE_범위
                XX = LOCAL:1 - TB_ANGLE_범위
                DONE:1 = 2
            ENDIF
        ENDIF
    NEXT
NEXT
IF DONE:0 == 2 || DONE:1 == 2
    이동력 -= SQRT(POWER(XX,2) + POWER(YY,2) + POWER(ZZ,2))
    GOTO END
ENDIF

WHILE 이동력 > 0
    이동력--
    IF ABS(XX) + ABS(YY) < XY한계
        SELECTCASE T_ANGLE_TAN(X목표 - TB_ANGLE_범위 + XX, Y목표 - TB_ANGLE_범위 + YY)
            CASE 0
                ;동
                XX++
            CASE 1 TO 89
                ;남동
                XX++
                YY++
            CASE 90
                ;북
                YY++
            CASE 91 TO 179
                ;남서
                XX--
                YY++
            CASE 180
                ;서
                XX--
            CASE -180 TO -91
                ;북서
                XX--
                YY--
            CASE -90
                ;남
                YY--
            CASE -79 TO -1
                ;북동
                XX++
                YY--
        ENDSELECT
    ENDIF
    IF ABS(ZZ) < Z한계
        IF Z목표 - ZZ > 0
            ZZ++
        ELSEIF Z목표 - ZZ < 0
            ZZ--
        ENDIF
    ENDIF
WEND
$END
RESULT:0 = 0
IF SIGN(XX) == -1
    RESULT:0 += 1
ENDIF
IF SIGN(YY) == -1
    RESULT:0 += 2
ENDIF
IF SIGN(ZZ) == -1
    RESULT:0 += 4
ENDIF
RESULT:0 = RESULT:0 * 100 + ABS(XX)
RESULT:0 = RESULT:0 * 100 + ABS(YY)
RESULT:0 = RESULT:0 * 100 + ABS(ZZ)
RESULT:0 = RESULT:0 * 100 + 이동력
;1,1,1,1이라면 1 001 001 001
;복원은 /1000000000 /1000000 /1000
RETURNF RESULT:0

@T_ANGLE_TAN(XX,YY)
#FUNCTION
#DIM DYNAMIC XX ;DX
#DIM DYNAMIC YY ;DY
IF ABS(XX) <= TB_ANGLE_범위 && ABS(YY) <= TB_ANGLE_범위
    ;표 TB_ANGLE_범위인 -10~10이내라면 표를 그대로 사용
ELSEIF XX == 0 || YY == 0 || (XX == YY)
    ;8방위에 속하는 각은 미리 처리
    IF XX == 0
        ;-90 <-> 90
        RETURNF 90 * SIGN(YY)
    ELSEIF YY == 0
        ;180 <-> 0
        RETURNF 90 + (SIGN(XX) * -90)
    ELSE
        RETURNF SIGN(YY) * (90 + (SIGN(XX) * -45))
    ENDIF
ELSEIF ABS(XX) > TB_ANGLE_범위 || ABS(YY) > TB_ANGLE_범위
    ;표보다 멀리 떨어짐
    IF ABS(XX) <= 1 || ABS(YY) <= 1
        GOTO ONLYONE
    ENDIF
    FOR LOCAL,0,30
        ;동일비율로 2배 축소시키면서 본다 
        XX /= 2
        YY /= 2
        IF ABS(XX) <= TB_ANGLE_범위 && ABS(YY) <= TB_ANGLE_범위
            BREAK
        ENDIF
        IF ABS(XX) <= TB_ANGLE_범위 || ABS(YY) <= TB_ANGLE_범위 
            GOTO ONLYONE
        ENDIF
    NEXT
ELSEIF ABS(XX) <= TB_ANGLE_범위 || ABS(YY) <= TB_ANGLE_범위
    ;둘중 하나만 TB_ANGLE_범위 내고 하나만 멀리 떨어진 경우라면 멀리 떨어진 부분을 10으로 고정
    $ONLYONE
    IF ABS(XX) <= TB_ANGLE_범위 
        ;YY = TB_ANGLE_범위 * SIGN(YY)
        YY /= ABS(XX)
        XX = 1 * SIGN(XX)
        IF ABS(YY) > 10
            ;아직도 높다면 어쩔수없이 10 고정
            YY = 10 * SIGN(YY)
        ENDIF
    ELSE
        ;XX = TB_ANGLE_범위 * SIGN(XX)
        XX /= ABS(YY)
        YY = 1 * SIGN(YY)
        IF ABS(XX) > 10
            ;아직도 높다면 어쩔수없이 10 고정
            XX = 10 * SIGN(XX)
        ENDIF
    ENDIF
ELSE
    ;예외인데 가능성이 있나?
ENDIF
DEBUGPRINTFORML {TB_ANGLE_차트:(YY + TB_ANGLE_범위):(XX + TB_ANGLE_범위)} FROM {YY + TB_ANGLE_범위}:{XX + TB_ANGLE_범위}
RETURNF TB_ANGLE_차트:(YY + TB_ANGLE_범위):(XX + TB_ANGLE_범위)

@TB_RANDANGLE()
#FUNCTION
RETURNF TB_ANGLE_차트:(RAND:21):(RAND:21)


;어떤 점이 있으면 그걸 해당 방향으로 이격시킨 좌표를 INT로 준다
@TB_POINTMOVE(원좌표,이동값,방향,Z기동력 = 0)
#FUNCTION
#DIM REF 원좌표,0
#DIM DYNAMIC 이동값
#DIM REF 방향,0
#DIMS DYNAMIC TEMP_MOVE
#DIM DYNAMIC 좌표변동방향,3
#DIM DYNAMIC 좌표,3
#DIM DYNAMIC Z기동력

VARSET LOCAL
좌표:0 = 원좌표:0 ;원 좌표가 오염될까봐...
좌표:1 = 원좌표:1
좌표:2 = 원좌표:2
DEBUGPRINTFORML ({원좌표:0},{원좌표:1},{원좌표:1}): 각도 {방향}도, 거리{이동값}
IF !Z기동력 ;Z기동 불가시엔 Z각도를 제거
    방향:1 = 0
ENDIF
WHILE 이동값 >= 1 && LOCAL < 100
    LOCAL++
    LOCAL:1 = T_ANGLE_TAN_TO_WAY_F(방향:0,이동값,방향:1,Z기동력)
    LOCAL:2 = LOCAL:1 / 1000000000
    LOCAL:3 = (LOCAL:1 % 1000000000) / 1000000
    LOCAL:4 = (LOCAL:1 % 1000000) / 1000
    이동값 = LOCAL:1 % 1000
    DEBUGPRINTFORML XY이동값{이동값}, XYZ{LOCAL:2},{LOCAL:3},{LOCAL:4}
    좌표:0 = LIMIT(좌표:0 + LOCAL:2,0,TB_위치값한계)
    좌표:1 = LIMIT(좌표:1 + LOCAL:3,0,TB_위치값한계)
    좌표:2 = LIMIT(좌표:2 + LOCAL:4,0,TB_위치값한계)
WEND
RETURNF TB_LOCATETOINT(좌표)


@TB_ANGLE_DATE_SET()
;TB_ANGLE_차트:00:0=  000, 001, 002, 003, 004, 005, 006, 007, 008, 009, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
TB_ANGLE_차트:20:0 =  135, 131, 128, 124, 120, 116, 111, 106, 101,  95, 90, 84, 78, 73, 68, 63, 59, 55, 51, 48, 45
TB_ANGLE_차트:19:0 =  138, 135, 131, 127, 123, 119, 113, 108, 102,  96, 90, 83, 77, 71, 66, 60, 56, 52, 48, 45, 41
TB_ANGLE_차트:18:0 =  141, 138, 135, 131, 126, 122, 116, 110, 104,  97, 90, 82, 75, 69, 63, 57, 53, 48, 45, 41, 38
TB_ANGLE_차트:17:0 =  145, 142, 138, 135, 130, 125, 119, 113, 105,  98, 90, 81, 74, 66, 60, 54, 49, 45, 41, 37, 34
TB_ANGLE_차트:16:0 =  149, 146, 143, 139, 135, 129, 123, 116, 108,  99, 90, 80, 71, 63, 56, 50, 45, 40, 36, 33, 30
TB_ANGLE_차트:15:0 =  153, 150, 147, 144, 140, 135, 128, 120, 111, 101, 90, 78, 68, 59, 51, 45, 39, 35, 32, 29, 26
TB_ANGLE_차트:14:0 =  158, 156, 153, 150, 146, 141, 135, 126, 116, 104, 90, 75, 63, 53, 45, 38, 33, 29, 26, 23, 21
TB_ANGLE_차트:13:0 =  163, 161, 159, 156, 153, 149, 143, 135, 123, 108, 90, 71, 56, 45, 36, 30, 26, 23, 20, 18, 16
TB_ANGLE_차트:12:0 =  168, 167, 165, 164, 161, 158, 153, 146, 135, 116, 90, 63, 45, 33, 26, 21, 18, 15, 14, 12, 11
TB_ANGLE_차트:11:0 =  174, 173, 172, 171, 170, 168, 165, 161, 153, 135, 90, 45, 26, 18, 14, 11,  9,  8,  7,  6,  5
TB_ANGLE_차트:10:0 =  180, 180, 180, 180, 180, 180, 180, 180, 180, 180,360,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
TB_ANGLE_차트:09:0 = -175,-174,-173,-172,-171,-169,-166,-162,-154,-135,-90,-45,-27,-19,-15,-12,-10, -9, -8, -7, -6
TB_ANGLE_차트:08:0 = -169,-168,-166,-165,-162,-159,-154,-147,-135,-117,-90,-64,-45,-34,-27,-22,-19,-16,-15,-13,-12
TB_ANGLE_차트:07:0 = -164,-162,-160,-157,-154,-150,-144,-135,-124,-109,-90,-72,-57,-45,-37,-31,-27,-24,-21,-19,-17
TB_ANGLE_차트:06:0 = -159,-157,-154,-151,-147,-142,-135,-127,-117,-105,-90,-76,-64,-54,-45,-39,-34,-30,-27,-24,-22
TB_ANGLE_차트:05:0 = -154,-151,-148,-145,-141,-135,-129,-121,-112,-102,-90,-79,-69,-60,-52,-45,-40,-36,-33,-30,-27
TB_ANGLE_차트:04:0 = -150,-147,-144,-140,-135,-130,-124,-117,-109,-100,-90,-81,-72,-64,-57,-51,-45,-41,-37,-34,-31
TB_ANGLE_차트:03:0 = -146,-143,-139,-135,-131,-126,-120,-114,-106, -99,-90,-82,-75,-67,-61,-55,-50,-45,-42,-38,-35
TB_ANGLE_차트:02:0 = -142,-139,-135,-132,-127,-123,-117,-111,-105, -98,-90,-83,-76,-70,-64,-58,-54,-49,-45,-42,-39
TB_ANGLE_차트:01:0 = -139,-135,-132,-128,-124,-120,-114,-109,-103, -97,-90,-84,-78,-72,-67,-61,-57,-53,-49,-45,-42
TB_ANGLE_차트:00:0 = -135,-132,-129,-125,-121,-117,-112,-107,-102, -96,-90,-85,-79,-74,-69,-64,-60,-56,-52,-49,-45
;xy -10~10까지의 atan2 * 180/pi값
